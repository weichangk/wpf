### WPF事件

#### 树形结构
<p>
路由(Route)：起点与终点间有若干个中转站，从起点出发后经过每中转站时要做出选择，最终以正确的路径到达终点。WPF事件的路由环境是UI组件树。WPF有两种树，一种叫逻辑树(Logical Tree)；一种叫可视元素树(Visual Tree)。Logical Tree最显著的特点就是它完全由布局组件和控件构成，它的每个结点不是布局组件就是控件。可视元素树基本上是逻辑树的一种扩展。逻辑树的每个结点都被分解为它们的核心可视化组件。逻辑树的结点对我们而言基本是一个黑盒。而可视元素树不同，它暴露了可视元素的实现细节。实际上WPF的事件处理是基于可视元素树(Visual Tree)的，而非逻辑树(Logical Tree)，而属性继承(Property Inheritance)以及资源查找(Resource Lookup)则是基于逻辑树的。WPF中还提供了遍历逻辑树和可视元素树的辅助类：System.Windows.LogicalTreeHelper和System.Windows.Media.VisualTreeHelper。
</p>

#### 事件的来龙去脉
事件模型
- 事件的拥有者：即消息的发送者。事件的宿主可以在某些条件下激发它拥有的事件，即事件被触发。事件被触发则消息被发送。
- 事件的响应者：即消息的接收者、处理者。事件接收者使用其事件处理器(Event Handler)对事件做出响应。
- 事件的订阅关系：事件的拥有者可以随时激发事件，但事件发生后会不会得到响应要看有没有事件的响应者，或者说要看这个事件是否被关注。如果对象A关注对象B的某个事件是否发生，则称A订阅了B的事件。更进一步讲，事件实际上是一个使用event关键字修饰的委托(Delegate)类型成员变量，事件处理器则是一个函数，说A订阅了B的事件，本质上就是让B.Event与A.EventHandler关联起来。所谓事件激发就是B.Event被调用，这时与其关联的A.EventHandler就会被调用。

CLR事件本质上是一个用event关键字修饰的委托实例。每对消息是“发送一响应”关系，必须建立显式的点对点订阅关系。事件的宿主必须能够直接访问事件的响应者，不然无法建立订阅关系。


#### WPF路由事件
<p>
路由事件的事件拥有者和事件响应者之间则没有直接显式的订阅关系，事件的拥有者只负责激发事件，事件将由谁响应它并不知道，事件的响应者则安装有事件侦听器，针对某类事件进行侦听，当有此类事件传递至此时事件响应者就使用事件处理器来响应事件并决定事件是否可以继续传递。
</p>


##### 使用WPF内置路由事件

##### 自定义路由事件
创建自定义路由事件三步骤
- 声明并注册路由事件
- 为路由事件添加CLR事件包装
- 创建可以激发路由事件额方法


##### RoutedEventArgs的Source与OriginalSource


##### 附加事件



